CCEffect %{
common-pass-config: &common-pass-config
    blendState:
        targets:
            - blend: true # 开启Blending混合模式,避免透明度为0的像素写入缓冲区(png)
              blendSrc: src_alpha
              blendDst: one_minus_src_alpha
              blendDstAlpha: one_minus_src_alpha
    depthStencilState: # 如果是2D渲染,可以关闭深度测试和写入 因为没有Z 轴
        depthTest: false
        depthWrite: false
    rasterizerState: # 光栅化状态配置
        cullMode: none # 不进行背面剔除,用于2D spine
techniques:
    - name: grayscale
      passes:
          - vert: vs:vert # builtin header
            frag: grayscale-fs:frag
            <<: *common-pass-config

    - name: invert
      passes:
          - vert: vs:vert # builtin header
            frag: invert-fs:frag
            <<: *common-pass-config
            
    - name: pixelSize
      passes:
          - vert: vs:vert # builtin header
            frag: pixelSize-fs:frag
            <<: *common-pass-config

    - name: edgeDetection
      passes:
          - vert: vs:vert # builtin header
            frag: edgeDetection-fs:frag
            <<: *common-pass-config

    - name: filmgrain
      passes:
          - vert: vs:vert # builtin header
            frag: filmgrain-fs:frag
            <<: *common-pass-config

    - name: vignette
      passes:
          - vert: vs:vert # builtin header
            frag: vignette-fs:frag
            <<: *common-pass-config

    - name: filmcurve
      passes:
          - vert: vs:vert # builtin header
            frag: filmcurve-fs:frag
            <<: *common-pass-config

    - name: filmColorGrade
      passes:
          - vert: vs:vert # builtin header
            frag: filmColorGrade-fs:frag
            <<: *common-pass-config

    - name: lut #色彩滤镜
      passes:
          - vert: vs:vert # builtin header
            frag: lut-fs:frag
            <<: *common-pass-config
            properties:
                timeFactor: {value: 0.0 , editor: {tooltip: "时间因子"}}

    - name: lutMore #更多色彩滤镜
      passes:
          - vert: vs:vert # builtin header
            frag: lutMore-fs:frag
            <<: *common-pass-config
            properties:
                textureSize: { value: [192, 192] } 
                timeFactor: {value: 0.0 , editor: {tooltip: "时间因子"}}


}%

CCProgram vs %{
#include "../chunks/normal-vert.chunk"
}%

CCProgram grayscale-fs %{
    precision highp float;
    #include <builtin/internal/sprite-texture>

    in vec2 uv0;

    #if USE_LOCAL
        in vec4 v_color;
    #endif

    vec4 graysacle(vec4 color) {
        float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
        return vec4(vec3(gray), color.a);
    }

    vec4 frag() {
        vec4 color = texture(cc_spriteTexture, uv0);
        #if USE_LOCAL
            color *= v_color;
        #endif
        return graysacle(color);
    }
}%

CCProgram invert-fs %{
    precision highp float;
    #include <builtin/internal/sprite-texture>

    in vec2 uv0;

    #if USE_LOCAL
        in vec4 v_color;
    #endif

    vec3 invert(vec3 color) {
        return vec3(1.0 - color.rgb);
    }

    vec4 frag() {
        vec4 color = texture(cc_spriteTexture, uv0);
        #if USE_LOCAL
            color *= v_color;
        #endif

        float cutoff = 0.01;
          // float mask = step(cutoff,color.a)
        float mask = smoothstep(cutoff,cutoff + 0.9,color.a);

        vec3 inverted = invert(color.rgb);
        color.rgb = mix(color.rgb, inverted, mask);
        return color;
    }
}%

CCProgram pixelSize-fs %{
    precision highp float;
    #include <builtin/internal/sprite-texture>

    in vec2 uv0;

    #if USE_LOCAL
        in vec4 v_color;
    #endif


    float pixelSize = 30.0;

    vec4 pixelate(vec2 uv){
        vec2 pixelCoord = floor(uv * pixelSize) / pixelSize;
        return texture(cc_spriteTexture, pixelCoord);
    }

    vec4 frag(){
        vec4 color = pixelate(uv0);
        #if USE_LOCAL
            color *= v_color;
        #endif
        return color;
    }
}%

CCProgram edgeDetection-fs %{
    precision highp float;
    #include <builtin/internal/sprite-texture>

    in vec2 uv0;

    #if USE_LOCAL
        in vec4 v_color;
    #endif

    // #计算单个像素在UV空间中的尺寸 通过 uv +- pixelSize 精确采样到周围半个像素的位置
    // vec2 texSize = textureSize(cc_spriteTexture,0);
    // vec2 pixelSize = 1.0/textureSize;
    vec2 pixelSize = vec2(1.0/314.0, 1.0/202.0);
    // 多通道处理（而不是只处理 R 通道），可以使用亮度计算
    float luminance(vec4 c) {
        return 0.299*c.r + 0.587*c.g + 0.114*c.b;
    }

    vec4 frag(){
        vec4 color = texture(cc_spriteTexture, uv0);

        #if USE_LOCAL
            color *= v_color;
        #endif
        
        vec4 top = texture(cc_spriteTexture, uv0 + vec2(0.0,pixelSize.y));
        vec4 topLeft = texture(cc_spriteTexture, uv0 + vec2(-pixelSize.x,pixelSize.y));
        vec4 topRight = texture(cc_spriteTexture, uv0 + vec2(pixelSize.x,pixelSize.y));

        vec4 left = texture(cc_spriteTexture, uv0 + vec2(-pixelSize.x,0.0));
        vec4 right = texture(cc_spriteTexture, uv0 + vec2(pixelSize.x,0.0));

        vec4 bottom = texture(cc_spriteTexture, uv0 + vec2(0.0,-pixelSize.y));
        vec4 bottomLeft  =  texture(cc_spriteTexture, uv0 + vec2(-pixelSize.x,-pixelSize.y));
        vec4 bottomRight  =  texture(cc_spriteTexture, uv0 + vec2(pixelSize.x,-pixelSize.y));

        // soble 算子
        vec4 gx = -topLeft - 2.0 * left - bottomLeft + topRight + 2.0 * right + bottomRight;
        vec4 gy = -topLeft - 2.0 * top - topRight + bottomLeft + 2.0 * bottom + bottomRight;

        // 计算梯度的长度
        // float edge = length(vec2(gx.r, gy.r)); // 计算当前像素的梯度长度
        float edge = length(vec2( luminance(gx), luminance(gy) )); // 计算当前像素的梯度长度
        edge = smoothstep(0.1, 0.3, edge);

        vec3 orig = color.rgb;
        return vec4(orig.rgb * (1.0 - edge), color.a);
    }
}%

CCProgram filmgrain-fs %{
    precision highp float;
    #include <builtin/internal/sprite-texture>
    #include <builtin/uniforms/cc-global>

    in vec2 uv0;
    #if USE_LOCAL
        in vec4 v_color;
    #endif

    // 胶片颗粒
    float filmgrain(vec2 uv0,float time){
        return fract(sin(dot(uv0 * time,vec2(12.9898,78.233)))*43758.5453);
    }

    vec4 frag(){
        vec4 color = texture(cc_spriteTexture, uv0);
        #if USE_LOCAL
            color *= v_color;
        #endif
        float alpha = color.a;
        if(alpha < 0.01){
            return color;
        }
        // 1 基础使用
        // float grain = filmgrain(uv0, cc_time.x);
        // float grainStrength = 0.12;
        // float centeredNoise = grain - 0.5;

        // color.rgb = clamp(color.rgb + centeredNoise * grainStrength, 0.0, 1.0);

        // 2 按照通道控制强度
        // vec3 strength = vec3(0.10,0.08,0.12);
        // float centeredNoise = filmgrain(uv0, cc_time.x) ;
        // color.rgb = clamp(color.rgb + centeredNoise * strength, 0.0, 1.0);

        // 3 每个通道用不同噪声
        // float nR = filmgrain(uv0 + vec2(13.1, 7.9), cc_time.x) - 0.5;
        // float nG = filmgrain(uv0 + vec2(2.3, 19.7), cc_time.x) - 0.5;
        // float nB = filmgrain(uv0 + vec2(5.6, 3.3), cc_time.x) - 0.5;
        // vec3 noise = vec3(nR, nG, nB);

        // vec3 strength = vec3(0.10, 0.08, 0.12);
        // color.rgb = clamp(color.rgb + noise * strength, 0.0, 1.0);

        // 4 亮度自适应的颗粒（暗部稍强、亮部稍弱，常见于胶片感）
        // 计算亮度（线性空间更合适，示例中简化）
        // float luma = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));
        // 让暗部颗粒更明显，亮部更弱
        // float adapt = mix(1.2, 0.6, luma);  // 暗->1.2，亮->0.6
        // float centeredNoise = filmgrain(uv0, cc_time.x) - 0.5;

        // float baseStrength = 0.10;
        // float finalStrength = baseStrength * adapt;

        // color.rgb = clamp(color.rgb + centeredNoise * finalStrength, 0.0, 1.0);

        // 5 多层噪声混合（低频+高频，提升质感）
        // float nHigh = filmgrain(uv0 * 1.0, cc_time.x) - 0.5;  // 高频
        // float nLow  = filmgrain(uv0 * 0.25, cc_time.x) - 0.5; // 低频(更大颗粒)

        // float centeredNoise = 0.7 * nHigh + 0.3 * nLow;       // 混合并保持零均值
        // float grainStrength = 0.10;

        // color.rgb = clamp(color.rgb + centeredNoise * grainStrength, 0.0, 1.0);

        // 6 动态强度（随时间轻微呼吸/闪烁）
        float t = cc_time.x;
        float anim = 0.5 + 0.5 * sin(t * 0.7);        // [0,1]
        float grainStrength = mix(0.08, 0.14, anim);  // 在 0.08~0.14 之间摆动
        
        float centeredNoise = filmgrain(uv0, t) - 0.5;
        color.rgb = clamp(color.rgb + centeredNoise * grainStrength, 0.0, 1.0);

        
        return color;
    }
}%

CCProgram vignette-fs %{
    precision highp float;
    #include <builtin/internal/sprite-texture>

    in vec2 uv0;
    #if USE_LOCAL
        in vec4 v_color;
    #endif

    float vignetteIntensity = 0.9; // 暗角强度

    float vignette(vec2 uv){

        vec2 center = vec2(0.5,0.5);
        float dist = distance(uv,center);

        return  smoothstep(0.1,0.9,dist * vignetteIntensity);
    }

    vec4 frag(){
        vec4 color = texture(cc_spriteTexture, uv0);
        #if USE_LOCAL
            color *= v_color;
        #endif

        if(color.a < 0.01){
            return color;
        }

        float vignetteFactor = vignette(uv0);
        color.rgb *= vignetteFactor;

        return color;
    }

}%

CCProgram filmcurve-fs %{
    precision highp float;
    #include <builtin/internal/sprite-texture>

    in vec2 uv0;
    #if USE_LOCAL
        in vec4 v_color;
    #endif


    vec3 filmcurve(vec3 color){
        vec3 x = color * 1.2;// 提亮图像
        // sigmoid 函数  = sigmoid(t) = 1 / (1 + exp(-t));
        vec3 curve = x * (1.0 / (1.0 + exp(-5.0 * (x-0.5)))); 

        return mix(color , curve, 0.7);
    }

    vec4 frag(){
        vec4 color = texture(cc_spriteTexture, uv0);
        #if USE_LOCAL
            color *= v_color;
        #endif

        float cutoff = 0.01;
        float mask = smoothstep(cutoff,cutoff + 1.0, color.a);

        vec3 filmcurved = filmcurve(color.rgb);
        
        color.rgb = mix(color.rgb, filmcurved, mask);
        return color;
    }
}%

CCProgram filmColorGrade-fs %{
    precision highp float;
    #include <builtin/internal/sprite-texture>

    in vec2 uv0;
    #if USE_LOCAL
        in vec4 v_color;
    #endif

    /// 橙青风格
    vec3 filmColorGrade(vec3 color){
        vec3 shadows = vec3(0.1,0.25,0.3); /// 青
        vec3 midtones = vec3(0.70,0.50,0.3); /// 橙

        float luminance = dot(color,vec3(0.2126, 0.7152, 0.0722)); // 亮度

        vec3 graded = mix(shadows,midtones,smoothstep(0.2,0.8,luminance));

        return mix(color, graded * color,0.4);
    }

    vec4 frag(){
        vec4 color = texture(cc_spriteTexture,uv0);
        #if USE_LOCAL
            color *= v_color;
        #endif

        vec3 gradedColor = filmColorGrade(color.rgb);

        return vec4(gradedColor,color.a);
    }
}%

CCProgram lut-fs %{
    precision highp float;
    #include <builtin/internal/sprite-texture>
    #include <builtin/uniforms/cc-global> // 引入时间 chunk
    #include "../chunks/filter.chunk" // 引入滤镜 chunk

    in vec2 uv0;
    #if USE_LOCAL
        in vec4 v_color;
    #endif

    uniform UBO_TIME{
        float timeFactor;
    };


    float grainIntensity = 3.25; 
    float vignetteIntensity = 2.0;

    vec4 film(vec4 color, vec2 uv ,float t) {
        /// 对比度
        color.rgb = filmCurve(color.rgb);
        /// 橙青色调
        color.rgb = filmColorGrade(color.rgb);
        // /// 褪色
        color.rgb = filmFade(color.rgb);
        // /// 添加暗角
        color.rgb *= vignette(uv,vignetteIntensity);

        ///  grain 噪点 颗粒
        float grain = filmGrain(uv,t) * grainIntensity;
        color.rgb += (grain -0.5) * 0.1; // 调整强度

        return color;
    }
    

    vec4 frag(){
        vec4 color  = texture(cc_spriteTexture,uv0);
        #if USE_LOCAL
            color *= v_color;
        #endif 

        float cutoff = 0.01;
        float mask = smoothstep(cutoff,cutoff + 1.0, color.a);

        float t = cc_time.x;
        vec4 films = film(color,uv0,t);
        /// 混合 防止透明区域被染成黑色
        color.rgb = mix(color.rgb, films.rgb, mask);

        return color;
    }
}%

CCProgram lutMore-fs %{
    precision highp float;
    #include <builtin/internal/sprite-texture>
    #include <builtin/uniforms/cc-global> // 引入时间 chunk
    #include "../chunks/filter.chunk" // 引入滤镜 chunk

    in vec2 uv0;
    #if USE_LOCAL
        in vec4 v_color;
    #endif

    uniform UBO_TIME{
        vec2 textureSize;
        float timeFactor;
    };

     // 故障效果
    vec4 glitchEffect(vec4 color,vec2 uv ,float t){
        float time = t * timeFactor;
        float intensity = 0.02;
        // 红色通道位移
        vec2 redUv = uv + vec2( cos(time *10.0)*intensity, sin(time *8.0)*intensity);
        float r = texture(cc_spriteTexture, redUv).r;

        // 绿色通道位移
        vec2 greenUV = uv + vec2(sin(time * 12.0) * intensity, cos(time * 9.0) * intensity);
        float g = texture(cc_spriteTexture, greenUV).g;
        
        // 蓝色通道位移
        vec2 blueUV = uv + vec2(cos(time * 7.0) * intensity, sin(time * 11.0) * intensity);
        float b = texture(cc_spriteTexture, blueUV).b;
        
        return vec4(r, g, b, color.a);
    }


    vec4 frag() {
        vec4 color = texture(cc_spriteTexture, uv0); 
        #if USE_LOCAL
            color *= v_color;
        #endif

        vec4 effe = color;
        #if USE_SEPIA
        effe = sepia(color);
        #elif USE_CYBERPUNK
        effe = cyberpunk(color);
        #elif USE_DUOTONE
        effe = duotone(color);
        #elif USE_GLITCH
        effe = glitchEffect(color, uv0, cc_time.x);
        #endif

        // float cutoff = 0.01;
        // float mask = smoothstep(cutoff,cutoff + 1.0, color.a);
        // color.rgb = mix(color.rgb, effe.rgb, mask);

        return effe;
    }
}%



